## 이벤트를 발생하는 작업

1. 이벤트를 정의한다.
2. 이벤트를 발생시켜야 할 경우 이벤트를 호출한다.
3. 호출된 이벤트에 결합되어 있는 이벤트 핸들러가 호출된다.

이때, 만약 호출된 이벤트에 결합되어 있는 이벤트 핸들러가 없다면 어떻게 될까요?

## C# 6.0 null 조건 연산자

이벤트에 이벤트 핸들러가 결합돼 있지 않다면 이벤트는 `null`값을 가지기 때문에 `NullReferenceException` 예외가 발생합니다.

### 해결책 1 : 이벤트 발생 전 결합 확인 코드 추가

```csharp
public void RasieUpdates()
{
	counter++;
	if(Updated != null)
		Updated(this, counter);
}
```

만약, `if`문을 호출 해 이벤트가 `null`이 아님을 확인 했지만 그 사이 다른 스레드에서 이벤트 핸들러의 등록을 취소한다면, 이벤트 핸들러는 `null` 값을 가지게 되므로 `NullReferenceException` 예외가 그대로 발생합니다.

즉, 멀티스레드 환경에서 위험할 수 있습니다.

### 해결책 2 : .NET과 C#을 이용해 안전하게 이벤트 관리

```csharp
public void RaiseUpdates()
{
	counter++;
	var handler = Updated;
	if(handler != null)
		handler(this, count)
}
```

스레드 안정성을 확보할 수 있습니다.

다른 스레드가 이벤트에 대한 구독을 취소해도 지역변수에는 이전에 만든 얕은 복사본 이벤트 핸들러가 그대로 남아있기 때문에 복사된 지역변수의 `null` 여부를 확인해 볼 수 있습니다.

하지만, 필요 없는 코드처럼 보이거나 복잡한 코드이기 때문에 코드의 가독성 측면에서는 문제가 있습니다.

### 해결책 3 : null 조건 연산자

```csharp
public void RaiseUpdates()
{
	counter++;
	Updated?.Invoke(this, counter);
}
```

null 조건 연산자를 사용해 안전하게 이벤트 핸들러를 호출합니다.

**null 조건 연산자 동작 방식**

`?.` 연산자의 왼쪽이 `null`인 경우 : 아무 작업도 수행하지 않고 다음 단락으로 이동

`?.` 연산자의 왼쪽이 `null`이 아닌 경우 : 연산자 오른쪽의 표현식을 실행

**if문과 차이점**

null 조건 연산자는 ? 연산자의 왼쪽을 평가하고 메서드를 수행하는 과정이 원자적으로 수행됩니다.

**Invoke() 메서드의 사용**

`Invoke()` : C# 컴파일러는 모든 델리게이트와 이벤트에 대해 타입 안정적인 형태로 생성해줍니다.
즉, 이 메서드를 호출하는 것은 `()` 를 이용해 이벤트를 직접 발생시키는 코드와 완전히 동일합니다.

`?` 연산자를 이용해 이벤트 발생 시 이벤트 이름 뒤 `()` 호출이 불가하므로 `Invoke()` 메서드를 사용합니다.

## 정리

- `null` 조건 연산자를 이용하는 방식은 `NullReferenceExceptions`에 대한 해결책으로 단순하고 명확합니다.
- 멀티스레드 환경에서 안전합니다.
- 헬퍼 메서드를 만들거나 독립적인 클래스를 작성할 필요가 없습니다.
