
## C#의 흐름 제어

- `for`
- `while`
- `do/while`
- `foreach`

다양한 반복 구문 존재하지만 쿼리 구문을 사용하는 것이 반복문을 사용하는 것보다 더 나은 경우가 있습니다.

## 쿼리 구문

- 프로그램의 논리를 명령형 방식에서 선언적인 방식으로 전환할 수 있습니다.
- 질의의 내용을 구성할 수 있을 뿐 아니라 개별 항목에 대해 수행하려는 작업의 수행 시기를 연기할 수 있습니다.
- 구문을 확장해 사용하면 루프를 이용하는 것보다 사용자의 의도를 더 명확하게 드러낼 수 있습니다.
- 가독성과 재사용성이 좋습니다.
- 다양하게 조합이 가능합니다.

```csharp
//쿼리 구문
var foo = (from n in Enumerable.Range(0, 100)
						select n * n ).ToArray();

//확장 메서드
foo.ForAll((n) => Console.WriteLine(n.ToString()));
```

### [중첨 루프]

```csharp
//명령형 구문
private static UEnumerable<Tuple<int, int>> QueryIndices()
{
	for(var x = 0; x < 100; x++)
		for(var y = 0; y < 100; y++)
			yield return Tuple.Create(x,y);
}
//쿼리 구문
private static UEnumerable<Tuple<int, int>> QueryIndices()
{
	return from x in Enumerable.Range(0, 100)
				 from y in Enumerable.Range(0, 100)
				 select Tuple.Create(x, y);
}
```

- 명령형으로 구현한 코드보다 문제의 유형이 복잡해지더라도 단순함을 유지합니다.

### [다양한 조합]

- 쿼리 구문은 개별 항목에 대하여 수행해야 하는 작업을 작은 코드 블록으로 생성합니다.
    - `where` : 필터링
    - `order by` : 정렬
    - `select` : 프로젝션
- 쿼리 구문의 지연 수행 모델로 개별 항목에 대해 수행해야 하는 여러 작업을 하나로 조합할 수 있습니다.
    - 한 번의 순회 과정 동안 여러 작업을 결합해 단번에 수행할 수 있습니다.

→ 명령형 방식이 이처럼 사용되려면 임시 저장소를 사용하고 정렬 과정을 독립된 작업으로 수행해야 합니다.

## 메서드 호출 구문

메서드 호출 구문을 사용하는 경우에도 동일한 질의를 표현할 수 있습니다.

- 장점 :  쿼리 구문보다 자연스러운 경우도 있습니다.
- 단점 :  메서드를 어떻게 사용해야 하는지 기억해야 합니다.

### [쿼리 구문을 사용할 수 없는 메서드]

- `Take`, `TakeWhile`, `Skip` 등은 메서드 호출 구문에서만 사용할 수 있습니다.

## 쿼리 구문 vs 루프 이용 구문

통상 루프를 이용해 직접 코딩하면 쿼리보다 성능이 좋은 코드를 작성할 수 있습니다.

! 하지만, 항상 그런것은 아닙니다. !

- 쿼리 구문의 성능이 만족스럽지 않다면 수행 성능을 측정하고 개선하기 위해서 LINQ에 대한 병렬 확장을 고려할 수 있습니다.

## 정리
