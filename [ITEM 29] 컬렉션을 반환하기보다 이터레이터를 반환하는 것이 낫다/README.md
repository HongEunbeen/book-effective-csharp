## LINQ

- 다양한 데이터 저장소에 대해 쿼리를 수행할 수 있는 통합 구문을 제공
- 지연된 쿼리를 지원

## 시퀀스의 반환

시퀀스를 반환하는 메서드 작성시 컬렉션보다 이터레이터를 반환하는 것이 좋습니다.

- 이터레이터를 이용해 다양한 작업을 좀 더 수월하게 수행할 수 있습니다.

## 이터레이터

- 이터레이터 메서드 : 호출자가 요청한 시퀀스를 생성하기 위해 `yield return` 문을 사용하는 메서드

```csharp
public static IEnumerable<char> GenerateAlphabet()
{
	var letter = 'a';
	while( letter <= 'z' )
	{
		yield return letter;
	}
}
```

### [컴파일러의 해석]

1. 이터레이터 메서드가 호출되면 컴파일러가 생성한 객체가 인스턴스화 됨
    
    → 생성된 객체는 실제 시퀀스에 대한 접근이 이루어지는 경우에만 사용함
    
2. 시퀀스 내에 포함된 항목을 요청하면 시퀀스가 생성됨

→ 동작 방식만 보면 시퀀스의 크기가 작은 경우 효율적이지 않지만 크기가 큰 경우는 효율적입니다.

### [이터레이터 장점]

- 이터레이터 메서드의 결과값을 추가적인 컬렉션에 저장하지 않는 이상 결과치를 저장하기 위한 공가닝 필요하지 않습니다.
- 필요할 때 생성 전략을 이용하기 때문에 효율적입니다.

### [이터레이터 주의점]

- 유효성 검사와 함께 사용한다면 시퀀스의 요소가 요청될 때까지 예외를 발생시키지 않을 수 있습니다.
    
    (즉, 시퀀스에 접근하려 할때 뒤늦게 예외가 발생합니다.)
    

→ 이를 해결하기 위해선 유효성 검사를 수행하는 부분과 실제로 시퀀스를 생성하는 부분을 분리해야 합니다.

코드를 분리하면 시퀀스에 접근하려 하면 즉각적으로 예외가 발생합니다.

## 이터레이터 메서드를 이용하는 경우

- 메서드가 반환하는 시퀀스를 캐싱할지에 대해서 사용자가 결정할 수 있도록 하는 것이 좋습니다.

→ `IEnumerable<T>`를 반환하도록 메서드를 작성하면 전체 값을 가져오는 것이 효율적인 경우, 필요한 시점에 맞쿼 값을 가져오는 경우 모두 손쉽게 대응할 수 있습니다.

## 정리

- 작성한 API들을 사용자들이 어떻게 사용할지 예측할 수 없기 때문에 API를 좀 더 쉽게 사용할 수 있도록 배려하는 것에 집중하는 것이 좋습니다.
- `IEnumerable<T>`와 같은 인터페이스를 반환하도록 메서드를 작성하는 편이 좀 더 편리합니다.
    - 필요할 때마다 하나씩 항목 생성 가능
    - `ToList()`를 이용해 전체 시퀀스가 저장된 컬렉션 생성 가능
