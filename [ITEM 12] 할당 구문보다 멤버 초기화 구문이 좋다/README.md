## 멤버 변수 초기화

생성자 내에서의 초기화는 자칫 초기화 코드를 누락할 수 있습니다.

따라서, 생성자의 본문에서 멤버 변수에 값을 할당하기보다 정적 변수와 인스턴스 변수 둘 다 멤버 초기화 구문을 사용하는 것이 좋습니다.

## 초기화 구문

```csharp
public class MyClass
{
	private List<string> labels = new List<string>();
}
```

멤버 변수를 선언할 때 객체를 함께 생성하는 것은 C#에서 자연스러운 구문이므로 멤버 변수를 선언할 때는 상항 초기화 구문을 사용해야 합니다.

### [생성자마다 멤버 변수 초기화 불필요]

컴파일러는 모든 생성자의 시작 부분에 멤버 추기화 구문을 포함시키기 때문에 새로운 생성자를 추가해도 항상 포함됩니다. 즉, 생성자마다 멤버 변수를 초기화 하지 않아도 됩니다.

### [생성자 내 멤버 변수 올바른 초기화]

멤버 초기화 구문에 의해 생성된 코드는 생성자 앞쪽에 붙여지는데 이는 생성하고자하는 타입이 다른 클래스를 상속하고 있는 경우 부모 클래스의 생성자가 호출되기 전 멤버에 대한 초기화가 이루어진다는 것을 의미합니다.

즉, 부모 클래스의 멤버 보다 먼저 자식 클래스의 멤버를 초기화 할 수 있습니다.

### [생성자 내 초기화 순서]

멤버 변수의 초기화 순서는 변수의 선언 순서대로 수행됩니다.

## 초기화 구문 사용 금지

### [객체를 0이나 null로 초기화 하는 경우]

기본 시스템 초기화 후틴은 코드를 실행하기 전 저수준에서 직접 CPU 명령으로 설정합니다.

```csharp
public struct MyValType  {}

MyValType myVal1; // 0으로 초기화
MyValType myVal2 = new MyValType(); //불필요한 0으로 초기화(반복해서 발생함)
```

C# 컴파일러는 이미 초기화 되어 있지만 초기화 구문이 있는 경우 또 코드를 생성하기에 불필요한 일을 추가합니다.

### [동일한 객체를 반복해서 초기화하는 경우]

객체를 생성하는 방식이 다양하게 혼재할 경우 멤버 초기화 구문을 사용하지 않는 것이 좋습니다.

```csharp
public class MyClass2
{
	private List<string> labels = new List<string>();
	MyClass2() {}
	MyClass2(int size) {labels = new List<string>(size);}
}
```

이렇게 코드를 작성하게 되면 두 번째 생성자에서 2개의 List<> 객체가 생성되고 하나는 즉각 가비지가 됩니다.

```csharp
MyClass2() 
{
	labels = new List<string>();
}

MyClass2(int size) 
{
	labels = new List<string>();
	labels = new List<string>(size);
}
```

암시적인 속성을 사용하는 경우에도 위 코드와 유사하게 중복 초기화가 발생할 수 있습니다.

### [예외 처리가 반드시 필요한 경우]

멤버 초기화 구문은 예외 처리가 불가하기 때문에 초기화 과정에서 예외가 발생하면 외부로 전파됩니다.

예외 처리가 필요하다면 멤버 초기화 구문 대신 생성자 내부로 초기화 코드를 옮기고 예외 처리 코드를 적절히 구현해야 합니다.

## 정리

- 멤버 초기화 구문을 이용하면 타입 내에서  멤버 변수 초기화 누락을 방지합니다.
- 모든 생성자가 동일한 방법으로 멤버 변수를 초기화하는 경우에 한해서만 사용해야 합니다.
- 멤버 초기화 구문을 사용하면 코드를 읽기도 쉽고 유지보수도 용이합니다.
