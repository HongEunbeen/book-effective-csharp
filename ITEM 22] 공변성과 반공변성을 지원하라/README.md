## 타입의 가변성

공변과 반공변은 특정 타입의 객체를 다른 타입의 객체로 변환할 수 있는 성격입니다.

공변/반공변을 지워하면 API를 더 다양하고 안전하게 사용할 수 있습니다.

### [데코레이터]

제네릭 인터페이스, 델리게이트의 정의 부분에서 공변/반공변으로 지워한다는 의미로 추가합니다.

## 공변/반공변

타입 매개변수로 주어지는 타입들이 상호 호한 가능할 경우 이를 이용하는 제네릭 타입도 호환가능함을 추론합니다.

- `X`를 `Y`로 바꾸어 사용 가능 → `C<X>`를 `C<Y>`로도 바꿔 사용 가능 → `C<T>`는 공변
- `Y`를 `X`로 바꾸어 사용 가능 → `C<X>`를 `C<Y>`로도 바꿔 사용 가능 → `C<T>`는 반공변

### [가변성 미 지원]

C# 4.0 이전에는 제네릭 타입이 가변성을 지원하지 않았기때문에 공변과 반공변이 필요한 경우에도 컴파일러는 이해하지 못했습니다.

```csharp
abstract public class A : IComparable<A> { }
public class B : A {}

public static void Unsafe(A[] baseItems)
{
	baseItem[0] = new B(); // 파생 클래스의 객체를 베이스 클래스 배열에 할당하면 예외 발생
}
```

컴파일러는 엄밀하게 제네릭 타입을 다뤘고, 제네릭 타입은 모두 불변이었으며 타입 매개변수가 다른 경우 대체가 불가능했습니다.

### [C# 4.0이후]

공변과 반공변을 지원하고 제네릭을 좀 더 유용하게 사용할 수 있도록 in과 out 키워드가 추가되었습니다.

즉, 공변과 반공변을 통해서 제네릭  타입의 대체 가능성을 지정할 수 있게 되었습니다.

in,out 데코레이터로 제네릭 인터페이스와 델리게이트 선언 시 사용할 수 있습니다.

## IEnumberable<T> : 공변 인터페이스

```csharp
public interface IEnumerable<out T> : IEnumerable
{
	new IEnumerator<T> GetEnumerator();
}
public interface IEnumerator<out T> : IDisposable, IEnumerator
{
	new T Current {get;}
}
```

### [out 데코레이터]

타입 매개변수 T를 출력 위치에서만 사용하겠다고 컴파일러에게 알려주는 역할을 합니다.

출력의 개념은 함수의 반환값, 속성의 get 접근자, 델리게이트의 일부 위치에서만 T를 사용할 수 있음을 의미합니다.

이를 통해 컴파일러는 시퀀스 내에서 T의 내용을 조회는 하겠지만 내용을 수정하지는 않습니다.

## IComparable<T> : 반공변 인터페이스

```csharp
public interface IComparable<in T>
{
	int CompareTo(T other);
}
```

### [in 데코레이터]

in을 사용하면 컴파일러에게 타입 매개변수를 입력 위치에서만 사용할 것이라고 알려주게 됩니다.

in을 지정한 타입 매개변수는 메서드의 매개변수를 지정하거나 일부 델리게이트의 매개변수를 지정하는 용도로만 사용할 수 있습니다.

## 델리게이트의 메개변수에 대한 공변/반공변

메서드의 매개변수 타입은 반공변(in)이고 메서드의 반환 타입은 공변(out)입니다.

주의할 점이 있습니다.

- 공변 인터페이스에 불변 인터페이스를 반환할 수는 없습니다.
- 하나의 타입에 공변화 반공변을 한꺼번에 지정할 수는 없습니다.

## 정리

- 공변과 반공변이 어떻게 동작하는지 설명하는것은 어렵지만 언어 차원에서 제네릭 인터페이스와 델리게이트 정의 시 사용할 수 있는 in, out 데코레이터가 존재합니다.
- 제네릭 인터페이스과 제네릭 델리게이트를 정의할 떄 in, out 데코레이터를 반드시 사용하는 것이 좋습니다.
    
    → 가변성과 관련한 오류를 컴파일러가 사전에 확인 할 수 있습니다.
