# ITEM 2: const보다는 readonly가 좋다

## C#에서의 상수

C#에는 컴파일타임 상수와 런타임 상수 두 가지의 상수가 존재합니다.

- `컴파일타임 상수(const)`
    
    ```csharp
    public const int Millennium = 2000;
    ```
    
- `런타임 상수(readonly)`
    
    ```csharp
    public static readonly int ThisYear = 2004;
    ```
    

이 두 상수는 서로 다르게 동작하기 때문에 적절하지 않은 상수 타입을 사용하면 문제가 발생합니다.

이때, `컴파일타임 상수(const)`보다는 `런타임 상수(readonly)`를 사용하는 것이 좋습니다.

## 컴파일타임 상수와 런타임 상수의 동작 방법

`컴파일타임 상수(const)`보다 `런타임 상수(readonly)`를 사용하는 것이 좋은 이유에 대해 알아보기 전 어떻게 동작하는지 알아보겠습니다.

두 상수는 값에 접근하는 방법에 따라 다르게 동작하고 동작 방법에 따라 각각의 다른 한계를 가지게 됩니다.

**컴파일타임 상수 동작 방법**

```csharp
if (myDateTime.Year == Millennium)

//위의 코드가 IL코드로 컴파일 되면 대체된다.
if (myDateTime.Year == 2000)
```

컴파일타임에 변수가 값으로 대체됩니다. 

바로 값으로 대체되기 때문에 속도는 빠르지만 유연성이 떨어집니다.

**런타임 상수 동작 방법**

런타임에 값이 평가됩니다. 즉, 컴파일 타임에 값으로 대체되지 않고 상수에 대한 참조로 컴파일이 된 후 런타임에서 값을 평가합니다.

동작을 할 때, 변수를 통해 값을 참조하므로 `컴파일타임 상수(const)`보다는 느린편에 속합니다.

## 컴파일타임 상수 vs 런타임 상수

**컴파일타임 상수의 한계점**

`컴파일타임 상수(const)`는 내장된 숫자형, enum, 문자열, null 등 내장 자료형에 대해서만 사용이 가능합니다. 

```csharp
//DateTime 타입은 내장 자료형이 아니기 때문에 컴파일되지 않는다!
private const DateTime classCreattion = new DateTime(2000, 1, 1, 0, 0, 0);
```

내장 자료형이어야만 컴파일타임에 상수를 리터럴로 대체할 수 있기 때문입니다.

**런타임 상수의 장점**

`런타임 상수(readonly)`는 값이 런타임에 평가되기 때문에 어떤 타입과도 함께 사용될 수 있습니다. 

또한, 멤버 초기화 구문 뿐 아니라 생성자를 통해서도 초기화가 가능합니다. 이러한 점을 이용해서 클래스 내에서 런 타임 상수를 정의해 인스턴스 별로 서로 다른 값을 가지게 할 수도 있습니다.

`컴파일타임 상수(const)`와 가장 중요한 차이점은 바로 상수의 값이 런타임에 평가된다는 것 입니다.

이 특징이 바로 응용프로그램을 유지보수할 때 상당한 영향을 미치기 때문입니다.

- `컴파일타임 상수(const)` : 다른 어셈블리의 참조 여부와 상관없이 항상 숫자나 문자열 등을 직접 사용한 것과 같은 동일한 IL 코드를 생성
- `런타임 상수(readonly)` : 컴파일 시 `readonly 변수`에 대한 참조 코드를 생성

이 점에서 중요하게 봐야 할 문제는 바로 호환성 문제 입니다.

```csharp
public class UsefulValues
{
	public static readonly int startValue  5; 
	public const int EndValue = 10;
}

for(int i = UsefulValues.StartValue; i < UsefulValues.EndValue; i++)
	Console.WriteLine("value is {0} ", i);
```

위 코드에서 만약 Infrastructure 어셈블리만 수정을 하게 된다면 응용프로그램 전체를 리빌드하지 않고 재 배포 할 수 있습니다.

이때,  `startValue = 100;` `EndValue = 1000;` 으로 배포를 하고 싶어 어셈블리를 통해 값을 변경해보겠습니다.

```csharp
public class UsefulValues
{
	public static readonly int startValue  500; 
	public const int EndValue = 100;
}

for(int i = UsefulValues.StartValue; i < UsefulValues.EndValue; i++)
	Console.WriteLine("value is {0} ", i);
```

이 코드는 작동하지 않습니다.

`startValue = 500` `EndValue = 10` 으로 r`eadonly 변수`만 변경되었기 때문입니다.

- `컴파일타임 상수(const)` : 컴파일 시 `const 변수`에 대한 참조 코드를 생성하지 않고 값으로 대체
- `런타임 상수(readonly)` : 컴파일 시 `readonly 변수`에 대한 참조 코드를 생성

만약, `컴파일타임 상수(const)`를 사용한다면 public으로 선언된 컴파일 타임 상수의 값을 수정하고 나서는 해당 상수를 참조하는 모든 코드를 반드시 재컴파일해야 합니다.

때문에, `런타임 상수(readonly)`를 사용한다면 이진 호환성과 기존 코드 모두 유지됩니다.

## 그럼 const를 사용해야 하는 상황이 있나요?

어셈블리에서 기존 값을 유지하고 싶을 경우

상숫값이 포함되어 있는 어셈블리에서 그 값을 변경하는 경우에도 이를 참조하는 다른 어셈블리를 재컴파일하기 전까지는 기존 값을 유지하고 싶을 경우에 사용합니다.

또한, 컴파일 할 때 사용되는 상숫값을 정의할 경우

특성의 매개변수, `switch/case` 문의 레이블, `enum` 정의 시 사용하는 상수에 사용합니다. 컴파일 할 떄 사용되는 상숫값의 경우 거의 수정되지 않는다는 특징이 있습니다.

성능 개선이 필요한 경우

`런타임 상수(readonly)`는 변수를 통해 값을 참조하기 때문에 `컴파일타임 상수(const)`보다는 느립니다.

하지만 성능 개선 효과가 크지 않다면 유연성을 해치지 않기 위해 `런타임 상수(readonly)`를 사용해야 합니다.

## 명명된 매개변수와 선택적 매개변수도 관련되어  있다?

선택적 매개변수에 대한 기본값은 `컴파일타임 상수(const)`의 형태로 메서드를 사용하는 측에 저장됩니다.

따라서 선택적 매개변수의 값을 변경할 때도 `const변수`와 마찬가지로 신중해야 합니다.

## 정리

`컴파일타임 상수(const)`가 더 빠르지만 `런타임 상수(readonly)`에 비해 유연성 떨어집니다.

그렇기 때문에, `컴파일타임 상수(const)`는 성능이 매우 중요하고 상수의 값이 절대로 바뀌지 않는 경우에만 제한적으로 사용해야합니다.
