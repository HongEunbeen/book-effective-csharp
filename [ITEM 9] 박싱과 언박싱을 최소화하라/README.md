## 박싱/언박싱

- 박싱 : 값 타입의 객체를 타입이 정해져 있지 않은 임의의 참조 타입 내부에 포함시키는 방법
- 언박싱 : 박싱되어 있는 참조 타입의 객체로부터 값 타입 객체의 복사본을 가져오는 방법

박싱과 언박싱은 반드시 필요한 메커니즘이지만 성능에 좋지 않은 영향을 미칩니다.

박싱 과정 중 새롭게 생성된 참조 타입의 객체는 힙에 생성되며, 값 타입의 복사본이 새롭게 생성된 객체 내부에 저장됩니다.

따라서 박싱과 언박싱은 가능한 한 피하는 것이 좋습니다.

## 피할수 없는 박싱/언박싱

제네릭 클래스와 제네릭 메서드로 박싱과 언박싱을 피할 수 있지만 API들은 여전히 박싱과 언박싱을 수행합니다.

`**System.Object`와 같은 참조 타입을 요구하는 곳에 값 타입의 객체 사용하는 경우**

```csharp
Console.WriteLine($"numbers : {fN}, {sN}");
```

보간 문자열을 만드는 작업은 System.Object 객체에 대한 배열을 사용합니다.

```csharp
int i = 35;
object o = i;
Console.WriteLine(o.ToString());
```

이렇게 박싱과 언박싱 작업이 개별 객체 단위로 이루어 집니다.

즉, 컴파일러는 값 타입의 객체를 `System.Object` 타입의 객체로 변환해야 하는 경우 항상 박싱과 언박싱 코드를 자동으로 생성해줍니다.

**인터페이스를 통해 값 타입의 객체를 참조하는 경우**

이럴때, 컴파일러는 경고 메시지를 출력하지 않고 박싱작업이 수행됩니다.

## 박싱을 피하는 규칙

**System.Object 타입으로 박싱이 이루어지는지 유심히 살펴보자**

```csharp
Console.WriteLine($@"numbers : {fN.ToString()}, {sN.ToString()}");
```

값 타입의 객체를 직접 전달하지 말고 문자열 인스턴스를 전달하는 것이 좋습니다.

**컬렉션을 사용하는 것을 피하고 제네릭 컬렉션을 사용하라**

컬렉션은 `System.Object` 타입의 객체에 대한 참조를 저장하도록 구현되어 있기에 값 타입의 객체를 추가하려는 경우 박싱이 발생합니다. 

또한, 컬렉션으로부터 객체를 가져오는 경우 객체의 복사본을 가져오기에 매번 객체애 대한 복사가 일어납니다.

## 정리

- 값 타입과 객체 타입의 변환 작업은 암시적으로 이뤄지며, 변환 작업이 행해지는지 찾기 어렵습니다.
- 박싱과 언박싱 작업은 부지불식간에 객체에 대한 복사본을 생성하는데 이로인해 버그가 발생할 수 있고 값 타입을 다형적으로 처리하는 과정에서 성능을 느리게 만듭니다.
- 값 타입을 `System.Object` 타입이나 인터페이스 타입으로 변경하는 코드는 작성하지 말아야 합니다.
