## 가비지 수집기(GC)

가비지 수집기는 관리되는 메모리를 관장하며 네이티브 환경과는 다르게 메모리 누수, 최고하되지 않는 포인터 등 메모리 관리 문제를 자동화 해줍니다.

가비지 수집기가 메모리를 전반적으로 관리해주기 때문에 상대적으로 응용프로그램의 구조를 단순하게 유지할 수 있습니다.

하지만, 데이터 베이스 연결, 시스템 객체 등과 같은 비관리 리소스는 여전히 개발자가 직접 관리해 줘야 합니다.

### [마크/콤팩트 알고리즘]

가비지 수집기는 마크/콤팩트 알고리즘을 사용하며 여러 객체 사이의 연관 관계를 효율적으로 파악해 더 이상 사용되지 않는 객체를 자동으로 제거합니다.

### [COM]

COM의 경우 개별 객체가 스스로 자신의 참조 여부나 횟수 등을 관리하도록 하지 않고, 응용 프로그램의 최상위 객체로부터 개별 객체까지의 도달 가능 여부를 확인하도록 설계되어 있습니다.

### [EntitySet]

`Entity`는 데이터베이스에서 로드한 객체들의 집합으로 구성되며 다른 `Entity`를 참조하는 링크를 포함할 수도 있습니다. 
`EntitySet`이 내부적으로 객체 간의 복잡한 참조 관계를 가지더라도 가비지 수집기가 메모리 해제를 책임지므로 개발자는 객체들을 개별적으로 해제하거나 참조 관계로 발새하는 문제에 대해 고민할 필요가 없습니다.

## 가비지 수집기 세대

.NET의 가비지 수집기는 가비지 수집 과정을 최적화하기 위해서 세대라는 개념을 사용합니다. 

세대를 통해 비교적 짧은 시간만 사용되는 객체를 다른 객체와 구분하여 가비지가 될 가능성이 높은 객체를 더 빠르게 찾아낼 수 있습니다.

- 0 세대 : 가비지 수집기가 수행된 이후 생성된 임의의 객체
- 1 세대 : 가비지 수집 후 여전히 쓰이고 있는 객체
- 2 세대 : 두 번 혹은 그 이상의 가비지 수집 절차 수행 후에서 쓰이고 있는 객체

## 가비지 수집기 수행과정

알고리즘으로 응용 프로그램 내의 최상위 객체로부터 참조 트리를 구성하여 도달 가능한 객체는 살아있는 객체로, 도달 불가능한 객체는 가비지로 간주해 수집합니다.

### [콤팩트 작업]

가비지 수집기가 수행되면 관리 힙에 대해 사용 중인 객체들을 한쪽으로 옮겨서 조각난 가용 메모리를 단일의 큰 메모리 공간으로 만드는 과정인 콤팩트 작업을 수행합니다.

즉, 사용되지 않는 객체를 제거할뿐 아니라 사용 중인 객체들을 옮겨 조각난 가용 메모리를 큰 메모리 공간으로 만드는 것입니다.

## 비관리 리소스

관리 힙에 대한 메모리 관리는 가비지 수집기가 완전한 책임을 집니다.

.NET Framework에서 비관리 리소스의 생명주기에 대해 개발자가 손쉽게 관리할 수 있도록 `finalizer`와 `IDisposable` 인터페이스라는 두 가지 메커니즘을 제공합니다.

### [finalizer]

비관리 리소스에 대한 해제 작업이 반드시 수행될 수 있도록 도와주는 방어적인 메커니즘입니다.

### [IDisposable]

`IDisposable`인터페이스를 통해 적시에 비관리 리소스가 빠르게 해제될 수 있도록 구현하면 됩니다.

.NET 환경에서 비관리 리소스를 해제하는 가장 좋은 방법입니다. 

## finalizer 문제점

사용자가 구현한 `finalizer`는 시간이 경과한 다음 가비지 수집기에 의해 호출되고 `finalizer`를 가지고 있는 객체는 가비지로 간주된 이후에도 긴 시간 메모리를 점유합니다.

즉, 정확히 어느 시점에 `finalizer`가 호출될 지 알 수 없습니다. .NET 환경이나 C#에서는 원하는 시점에 정확히 객체를 해제하는 기능을 제공하고 있지 않기 때문입니다.

### [문제점]

- `finalizer`를 사용하면 성능이 나빠집니다.
- `finalizer`를 포함하고 있는 객체를 사용하면 가비지 수집 과정이 더 길어집니다.
- 가비지 수집기가 `finalizer`를 포함하는 객체를 가비지로 판단한 경우 finalizer를 호출해야 하기때문에 즉시 객체가 점유하고 있는 메모리 공간을 해제하지 못합니다.
- `finalizer`를 가지고 있는 객체는 메모리를 더 오래 점유하고 `finalizer`를 수행하기 위해 추가적인 스레드가 필요합니다.

### [해결책]

`finalizer`가 할당된 비관리 리소스를 최종적으로 해제할 수 있는 유일한 방법이지만 `IDioposable`인터페이스와 `표준 Dispose 패턴`을 활용하면 가비지 수집과정이 지연되는 것을 방지 할 수 있습니다.

## 정리

- 메모리가 아닌 다른 시스템 리소스의 경우, 정리 작업을 해야 하기 때문에 `finalizer`가 반드시 필요하다.
- `finalizer`는 응용 프로그램의 성능에 심각한 영향을 미치므로 `IDisposable` 인터페이스를 구현해 가비지 수집과정이 지연되는 것을 방지해야 합니다.
