## C#에서의 형변환

 C#은 정적 타이핑을 수행하는 언어입니다. 

타입 불일치가 발생하더라도 컴파일러가 걸러주기때문에 런타임에 타입 검사를 수행할 필요가 없습니다.

하지만, 런타임에 타입을 확인해야 하는 경우도 있습니다.

**C#에서 형변환을 수행하는 방법**

- `as 연산자`
    
    ```csharp
    object o = Factory.GetObject();
    
    MyType t = o as MyType;
    
    if(t != null) {}
    else {}
    ```
    
- 컴파일러의 캐스트 연산자 구문
    
    ```csharp
    object o = Factory.GetObject();
    
    try
    {
    	MyType t;
    	t = (MyType) o;
    }
    catch(InvalidCastException)
    {}
    ```
    

C#에서 형변환 하는 방법은 두 가지 입니다.

여기서, 캐스팅을 사용하기보다 `as 연산자`를 사용하는 것이 좋습니다.

**캐스팅의 단점**

위 코드를 비교해보면 캐스팅의 단점이 확실히 드러납니다.

- `as 연산자`에 비해 작성하기 어렵고 읽기도 어렵습니다.
- 사용하기보다 `as 연산자`를 사용하는 것이 좋습니다.에 비해 `try/catch` 문으로 성능이 떨어집니다.
- null은 어떤 참조 타입으로도 형변환 될 수 있기 때문에 반환값이 null인지를 확인해야 합니다.
    
    → `as 연산자` : 형변환을 수행할 수 없거나, `null`을 대상으로 형변환 수행시 `null` 반환으로 `null 확인코드`만 필요
    
    → `캐스트` : `예외 처리코드`와 `null 확인 코드` 모두 필요
    

이러한 단점들로 as를 사용하는 편이 더 안전하기도 하고 런타임에 더 효율적으로 동작합니다.

다만, 객체의 타입이 런타임에 정확히 일치할 경우에만 형변환이 성공적으로 수행되기 때문에

 `as/is 연산자`를 사용하면 사용자 정의 형변환은 수행되지 않습니다.

## 👀 `캐스팅` vs `as 연산자`

두 연산자는 사용자 정의 형변환을 어떻게 다루는 가에 따라 차이점이 있습니다.

- `as/is 연산자` : 런타임에 객체의 타입을 확인하고 필요에 따라 박싱을 수행하는것을 제외하고 어떤한 작업도 수행하지 않습니다.
- `캐스팅` : 객체를 지정한 타입으로 변환하기 위해 형변환 연산자가 개입될 수 있습니다.

**사용자 정의 형변환**

사용자 정의 형변환 연산자는 객체의 `런타임 타입`이 아닌 `컴파일타임 타입`에 맞춰 수행됩니다.

런타임에 객체를 형변환할 수 있는지는 중요하지 않고 컴파일러는 이에 대해 알지도 고려하지도 않습니다. 

컴파일러는 런타임에 객체가 어떤 타입일지를 예측하지 못하기에 컴파일러는 단순히 컴파일 타임에 객체가 어떤 타입으로 선언됐는지만 추적하기만 합니다.

이렇기 때문에 `캐스팅`보다 `as 연산자`를 사용하는 것이 좋습니다.

```csharp
t = (MyType)st; 

t = st as MyType; //st가 MyType이나 MyTpye을 사용한 타입이 아니라면 컴파일 오류
```

- `as 연산자` : `st`가 어떤 타입으로 선언되었든 항상 동일한 경과를 반환합니다. (일관성이 높습니다.)
- `캐스팅`  : `st`가 어떤 타입으로 선언되었느냐에 따라 다르게 동작이 가능합니다.

## 🤨 as를 사용할 수 없는 경우

하지만, as를 사용할 수 없는 경우도 있습니다.

- `null`이 될 수 없는 값 타입
- `foreach 루프`와 함께 사용할 경우
- `GetType()` 메서드
- `Enumerable.Cast<T>()` 메서드

**null이 될 수 없는 값 타입**

```csharp
object o = Factory.GetValue();
int i = o as int; //컴파일 불가
```

`as 연산자`의 왼쪽 피연산자가 `값 타입`이거나 혹은 `nullable 값 타입`일 경우 언제든 사용 가능하지만 `null이 될 수 없는 값 타입`에는 사용이 불가합니다.

**foreach 루프와 함께 사용할 경우**

`foreach 루프`는 제네릭타입이 아닌 `IEnumberable 인터페이스`를 이용하는데 이를 구현하는 과정에서 형변환을 수행합니다.

```csharp
public void UseCollectionV2(IEnumberalbe theCollection)
{
	IEnumerator it = theCollection.GetEnumerator();
	while(it.MoveNext())
	{
		MyType t = (Mytype) it.Current; // 형변환 수행
		t.DoStuff();
	}
}
```

`foreach 루프`은 값 타입, 참조 타입 모두에 대해 형변환 지원해야 하므로 `foreach 루프`에서는 캐스팅을 통해 루프에서 사용되는 타입으로 객체를 형변환합니다.

- 장점 : 대상 타입을 구분할 필요없이 형변환이 가능합니다.
- 단점 : `InvalidCastException`이 발생할 가능성이 있습니다.

**GetType() 메서드**

임의의 객체를 다른 타입으로 형변환 가능하지와 객체의 정확한 타입을 알소 싶을때는 `GetType()` 메서드를 사용합니다.

- `is 연산자` : 다형성 규칙을 준수하기 때문에 상속 관계 타입일 경우에도 true를 반환합니다.
- `GetType() 메서드` : 런타임에 객체의 타입을 정확히 가져옵니다.

**Enumerable.Cast<T>() 메서드**

```csharp
var small22 = collection.Cast<int>().Where(item => item < 5).Select(n => n);
```

`Enumerable.Cast<T>()`메서드는  `IEnumerable` 인터페이스만을 지원하는 컬렉션에 포함된 각각의 객체에 대해 형변환을 수행할 때 사용합니다.

`Enumerable.Cast<T>()`에서  `as 연산자`를 사용하면 형변환하려는 타입에 제한이 생기기 때문에 형변환시  `as 연산자` 대신 `캐스트 연산자`를 사용합니다.

## 📌 정리

- 객체 지향 프로그래밍에서는 가능하면 형변환을 피하는 것이 좋습니다.
- 형변환이 필요한 경우 사용자의 의도를 명확히 표현할 수 있는 `is/ as 연산자`를 사용해야 합니다.
- `is/as 연산자`는 예상대로 동작하며 대상 객체를 올바르게 형변환할 수 있을 경우에만 성공합니다.
- 캐스트 연산보다 `is/as 연산자를` 사용하는 것이 의도하지 않은 부작용이나 예상치 못한 문제를 피할 수 있는 좋은 방법입니다.
