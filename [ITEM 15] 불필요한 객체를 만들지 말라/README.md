## 가비지 수집기

힙에서 새로운 객체를 생성하고 사제하는 작업은 상대적으로 많은 프로세서 시간을 사용합니다.

즉, 너무 많은 객체를 생성하면 성능 문제를 일으킬 수도 있습니다.

## GC 사용시 주의사항

GC가 과도하게 동작하지 않도록 객체 생성을 최소화하기 위한 두 가지 기법이 있습니다.

- 자주 사용되는 지역 변수를 멤버 변수로 변경
- 종속성 삽입을 활용해 자주 사용되는 객체를 생성해 재활용
- 변경 불가능한 타입

### [모든 참조 타입의 객체는 동적으로 메모리를 할당]

모든 참조 타입의 객체는 동적으로 메모리를 할당되어 참조가 사라져 버리면 가비지가 됩니다.

```csharp
protected override void OnPaint(PaintEventArgs e)
{
	using(Font MyGont = new Font("a", 10.0f)) {}
}
```

위 코드는 해당 메소드를 호출 할 때마다 `Font` 객체를 매번 다시 생성합니다.

이렇게 생성된 객체를 GC는 제거할 책임이 있기때문에 상당히 비효율적입니다.

### [1. 지역 변수가 아닌 멤버 변수]

자주 호출되는 메서드 내에서 참조 타입의 객체를 매번 생성하는 경우 지역변수보다 멤버 변수가 좋습니다.

지역 변수가 아닌 멤버 변수로 변경하면 한 번 생성 후 재사용할 수 있습니다.

하지만, `IDisposable`인터페이스를 구현한 타입의 객체하면 반드시 해당 클래스도 `IDisposable`을 구현해야 합니다.

### [2. 참조 타입의 인스턴스를 정적 멤버 변수로 선언]

특정 클래스는 내부적으로 지연평가 알고리즘을 사용해 해당 객체가 최초로 요청될 떄 필요한 객체를 생성합니다.

```csharp
private static Brucsh blackBrush;

public static Brush Black
{
	get 
	{
		if(blackBrush == null) blackBrush = new SolidBrush(Color.Black);
		return blackBrush;
	}
}
```

해당 클래스는 생성된 객체를 저장해두고 동일한 요청이 있을 때마다 해당 객체를 돌려줍니다.

결국 하나의 객체를 재사용할 수 있게 됩니다.

하지만 단점도 존재합니다.

- 경우에 따라 생성된 객체가 메모리상에 필요 이상으로 오랫동안 남아 있을 수 있습니다.
- `Dispose()` 메소드를 호출해야 할 시점을 결정할 수 없기에 비관리 리소스를 삭제할 수 없습니다.

### [3. 변경 불가능한 타입]

```csharp
string msg = "Hello, ";
string msg1 = "Helloo, ";
msg = msg1; // Hello,는 가비지가 됩니다.
```

`System.String`은 변경 불가능한 타입이므로 변경할 때 계속해서 새로운 객체를 가지기 때문에 가비지가 생성됩니다.

```csharp
string msg = string.Format("Hello, {0} ", DateTime.Now.ToString());
```

문자열 보간을 이용하면 새로운 객체를 만들지 않고 사용가능합니다.

더 복잡한 경우라면 `StringBuilder` 클래스를 사용합니다.

변경 불가능한 타입을 작성하는 경우 `StringBuilder`와 같은 기능을 함께 제공하는 것을 고려해야 합니다.

해당 기능 제공 시 사용자는 객체를 여러 단계를 거쳐 구성할 수 있으며 최종적으로 변경 불가능한 객체를 얻게되고 객체의 불변성을 유지하는데 도움이 됩니다.

## 정리

- 힙에서 객체를 생성하고 삭제하려면 시간이 필요하기 때문에 과도하게 생성는것을 피하고 불필요한 객체를 생성하지 말아야 합니다.
- 메서드 내에서 참조 타입을 객체로 만드는 것을 가능한 피해야 합니다.
- 지역 변수를 멤버변수로 변경하거나, 자주 사용하는 인스턴스를 정적 객체로 변경하는 것이 좋습니다.
- 변경 불가능한 타입을 작성하는 경우 대응하는 변경 가능한 빌더 클래스를 같이 작성하는 것을 고려해야 합니다.
